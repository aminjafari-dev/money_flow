// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_transaction_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LoadCategoriesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> categories) completed,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> categories)? completed,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> categories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadCategoriesInitial value) initial,
    required TResult Function(LoadCategoriesLoading value) loading,
    required TResult Function(LoadCategoriesCompleted value) completed,
    required TResult Function(LoadCategoriesError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadCategoriesInitial value)? initial,
    TResult? Function(LoadCategoriesLoading value)? loading,
    TResult? Function(LoadCategoriesCompleted value)? completed,
    TResult? Function(LoadCategoriesError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadCategoriesInitial value)? initial,
    TResult Function(LoadCategoriesLoading value)? loading,
    TResult Function(LoadCategoriesCompleted value)? completed,
    TResult Function(LoadCategoriesError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoadCategoriesStateCopyWith<$Res> {
  factory $LoadCategoriesStateCopyWith(
          LoadCategoriesState value, $Res Function(LoadCategoriesState) then) =
      _$LoadCategoriesStateCopyWithImpl<$Res, LoadCategoriesState>;
}

/// @nodoc
class _$LoadCategoriesStateCopyWithImpl<$Res, $Val extends LoadCategoriesState>
    implements $LoadCategoriesStateCopyWith<$Res> {
  _$LoadCategoriesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadCategoriesInitialImplCopyWith<$Res> {
  factory _$$LoadCategoriesInitialImplCopyWith(
          _$LoadCategoriesInitialImpl value,
          $Res Function(_$LoadCategoriesInitialImpl) then) =
      __$$LoadCategoriesInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadCategoriesInitialImplCopyWithImpl<$Res>
    extends _$LoadCategoriesStateCopyWithImpl<$Res, _$LoadCategoriesInitialImpl>
    implements _$$LoadCategoriesInitialImplCopyWith<$Res> {
  __$$LoadCategoriesInitialImplCopyWithImpl(_$LoadCategoriesInitialImpl _value,
      $Res Function(_$LoadCategoriesInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadCategoriesInitialImpl implements LoadCategoriesInitial {
  const _$LoadCategoriesInitialImpl();

  @override
  String toString() {
    return 'LoadCategoriesState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadCategoriesInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> categories) completed,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> categories)? completed,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> categories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadCategoriesInitial value) initial,
    required TResult Function(LoadCategoriesLoading value) loading,
    required TResult Function(LoadCategoriesCompleted value) completed,
    required TResult Function(LoadCategoriesError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadCategoriesInitial value)? initial,
    TResult? Function(LoadCategoriesLoading value)? loading,
    TResult? Function(LoadCategoriesCompleted value)? completed,
    TResult? Function(LoadCategoriesError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadCategoriesInitial value)? initial,
    TResult Function(LoadCategoriesLoading value)? loading,
    TResult Function(LoadCategoriesCompleted value)? completed,
    TResult Function(LoadCategoriesError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class LoadCategoriesInitial implements LoadCategoriesState {
  const factory LoadCategoriesInitial() = _$LoadCategoriesInitialImpl;
}

/// @nodoc
abstract class _$$LoadCategoriesLoadingImplCopyWith<$Res> {
  factory _$$LoadCategoriesLoadingImplCopyWith(
          _$LoadCategoriesLoadingImpl value,
          $Res Function(_$LoadCategoriesLoadingImpl) then) =
      __$$LoadCategoriesLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadCategoriesLoadingImplCopyWithImpl<$Res>
    extends _$LoadCategoriesStateCopyWithImpl<$Res, _$LoadCategoriesLoadingImpl>
    implements _$$LoadCategoriesLoadingImplCopyWith<$Res> {
  __$$LoadCategoriesLoadingImplCopyWithImpl(_$LoadCategoriesLoadingImpl _value,
      $Res Function(_$LoadCategoriesLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadCategoriesLoadingImpl implements LoadCategoriesLoading {
  const _$LoadCategoriesLoadingImpl();

  @override
  String toString() {
    return 'LoadCategoriesState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadCategoriesLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> categories) completed,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> categories)? completed,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> categories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadCategoriesInitial value) initial,
    required TResult Function(LoadCategoriesLoading value) loading,
    required TResult Function(LoadCategoriesCompleted value) completed,
    required TResult Function(LoadCategoriesError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadCategoriesInitial value)? initial,
    TResult? Function(LoadCategoriesLoading value)? loading,
    TResult? Function(LoadCategoriesCompleted value)? completed,
    TResult? Function(LoadCategoriesError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadCategoriesInitial value)? initial,
    TResult Function(LoadCategoriesLoading value)? loading,
    TResult Function(LoadCategoriesCompleted value)? completed,
    TResult Function(LoadCategoriesError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadCategoriesLoading implements LoadCategoriesState {
  const factory LoadCategoriesLoading() = _$LoadCategoriesLoadingImpl;
}

/// @nodoc
abstract class _$$LoadCategoriesCompletedImplCopyWith<$Res> {
  factory _$$LoadCategoriesCompletedImplCopyWith(
          _$LoadCategoriesCompletedImpl value,
          $Res Function(_$LoadCategoriesCompletedImpl) then) =
      __$$LoadCategoriesCompletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> categories});
}

/// @nodoc
class __$$LoadCategoriesCompletedImplCopyWithImpl<$Res>
    extends _$LoadCategoriesStateCopyWithImpl<$Res,
        _$LoadCategoriesCompletedImpl>
    implements _$$LoadCategoriesCompletedImplCopyWith<$Res> {
  __$$LoadCategoriesCompletedImplCopyWithImpl(
      _$LoadCategoriesCompletedImpl _value,
      $Res Function(_$LoadCategoriesCompletedImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? categories = null,
  }) {
    return _then(_$LoadCategoriesCompletedImpl(
      null == categories
          ? _value._categories
          : categories // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$LoadCategoriesCompletedImpl implements LoadCategoriesCompleted {
  const _$LoadCategoriesCompletedImpl(final List<String> categories)
      : _categories = categories;

  final List<String> _categories;
  @override
  List<String> get categories {
    if (_categories is EqualUnmodifiableListView) return _categories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categories);
  }

  @override
  String toString() {
    return 'LoadCategoriesState.completed(categories: $categories)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadCategoriesCompletedImpl &&
            const DeepCollectionEquality()
                .equals(other._categories, _categories));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_categories));

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadCategoriesCompletedImplCopyWith<_$LoadCategoriesCompletedImpl>
      get copyWith => __$$LoadCategoriesCompletedImplCopyWithImpl<
          _$LoadCategoriesCompletedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> categories) completed,
    required TResult Function(String message) error,
  }) {
    return completed(categories);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> categories)? completed,
    TResult? Function(String message)? error,
  }) {
    return completed?.call(categories);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> categories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(categories);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadCategoriesInitial value) initial,
    required TResult Function(LoadCategoriesLoading value) loading,
    required TResult Function(LoadCategoriesCompleted value) completed,
    required TResult Function(LoadCategoriesError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadCategoriesInitial value)? initial,
    TResult? Function(LoadCategoriesLoading value)? loading,
    TResult? Function(LoadCategoriesCompleted value)? completed,
    TResult? Function(LoadCategoriesError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadCategoriesInitial value)? initial,
    TResult Function(LoadCategoriesLoading value)? loading,
    TResult Function(LoadCategoriesCompleted value)? completed,
    TResult Function(LoadCategoriesError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class LoadCategoriesCompleted implements LoadCategoriesState {
  const factory LoadCategoriesCompleted(final List<String> categories) =
      _$LoadCategoriesCompletedImpl;

  List<String> get categories;

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadCategoriesCompletedImplCopyWith<_$LoadCategoriesCompletedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadCategoriesErrorImplCopyWith<$Res> {
  factory _$$LoadCategoriesErrorImplCopyWith(_$LoadCategoriesErrorImpl value,
          $Res Function(_$LoadCategoriesErrorImpl) then) =
      __$$LoadCategoriesErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$LoadCategoriesErrorImplCopyWithImpl<$Res>
    extends _$LoadCategoriesStateCopyWithImpl<$Res, _$LoadCategoriesErrorImpl>
    implements _$$LoadCategoriesErrorImplCopyWith<$Res> {
  __$$LoadCategoriesErrorImplCopyWithImpl(_$LoadCategoriesErrorImpl _value,
      $Res Function(_$LoadCategoriesErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$LoadCategoriesErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoadCategoriesErrorImpl implements LoadCategoriesError {
  const _$LoadCategoriesErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'LoadCategoriesState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadCategoriesErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadCategoriesErrorImplCopyWith<_$LoadCategoriesErrorImpl> get copyWith =>
      __$$LoadCategoriesErrorImplCopyWithImpl<_$LoadCategoriesErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> categories) completed,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> categories)? completed,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> categories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadCategoriesInitial value) initial,
    required TResult Function(LoadCategoriesLoading value) loading,
    required TResult Function(LoadCategoriesCompleted value) completed,
    required TResult Function(LoadCategoriesError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadCategoriesInitial value)? initial,
    TResult? Function(LoadCategoriesLoading value)? loading,
    TResult? Function(LoadCategoriesCompleted value)? completed,
    TResult? Function(LoadCategoriesError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadCategoriesInitial value)? initial,
    TResult Function(LoadCategoriesLoading value)? loading,
    TResult Function(LoadCategoriesCompleted value)? completed,
    TResult Function(LoadCategoriesError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class LoadCategoriesError implements LoadCategoriesState {
  const factory LoadCategoriesError(final String message) =
      _$LoadCategoriesErrorImpl;

  String get message;

  /// Create a copy of LoadCategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadCategoriesErrorImplCopyWith<_$LoadCategoriesErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LoadSubcategoriesState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> subcategories) completed,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> subcategories)? completed,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> subcategories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadSubcategoriesInitial value) initial,
    required TResult Function(LoadSubcategoriesLoading value) loading,
    required TResult Function(LoadSubcategoriesCompleted value) completed,
    required TResult Function(LoadSubcategoriesError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadSubcategoriesInitial value)? initial,
    TResult? Function(LoadSubcategoriesLoading value)? loading,
    TResult? Function(LoadSubcategoriesCompleted value)? completed,
    TResult? Function(LoadSubcategoriesError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadSubcategoriesInitial value)? initial,
    TResult Function(LoadSubcategoriesLoading value)? loading,
    TResult Function(LoadSubcategoriesCompleted value)? completed,
    TResult Function(LoadSubcategoriesError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoadSubcategoriesStateCopyWith<$Res> {
  factory $LoadSubcategoriesStateCopyWith(LoadSubcategoriesState value,
          $Res Function(LoadSubcategoriesState) then) =
      _$LoadSubcategoriesStateCopyWithImpl<$Res, LoadSubcategoriesState>;
}

/// @nodoc
class _$LoadSubcategoriesStateCopyWithImpl<$Res,
        $Val extends LoadSubcategoriesState>
    implements $LoadSubcategoriesStateCopyWith<$Res> {
  _$LoadSubcategoriesStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadSubcategoriesInitialImplCopyWith<$Res> {
  factory _$$LoadSubcategoriesInitialImplCopyWith(
          _$LoadSubcategoriesInitialImpl value,
          $Res Function(_$LoadSubcategoriesInitialImpl) then) =
      __$$LoadSubcategoriesInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadSubcategoriesInitialImplCopyWithImpl<$Res>
    extends _$LoadSubcategoriesStateCopyWithImpl<$Res,
        _$LoadSubcategoriesInitialImpl>
    implements _$$LoadSubcategoriesInitialImplCopyWith<$Res> {
  __$$LoadSubcategoriesInitialImplCopyWithImpl(
      _$LoadSubcategoriesInitialImpl _value,
      $Res Function(_$LoadSubcategoriesInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadSubcategoriesInitialImpl implements LoadSubcategoriesInitial {
  const _$LoadSubcategoriesInitialImpl();

  @override
  String toString() {
    return 'LoadSubcategoriesState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadSubcategoriesInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> subcategories) completed,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> subcategories)? completed,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> subcategories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadSubcategoriesInitial value) initial,
    required TResult Function(LoadSubcategoriesLoading value) loading,
    required TResult Function(LoadSubcategoriesCompleted value) completed,
    required TResult Function(LoadSubcategoriesError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadSubcategoriesInitial value)? initial,
    TResult? Function(LoadSubcategoriesLoading value)? loading,
    TResult? Function(LoadSubcategoriesCompleted value)? completed,
    TResult? Function(LoadSubcategoriesError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadSubcategoriesInitial value)? initial,
    TResult Function(LoadSubcategoriesLoading value)? loading,
    TResult Function(LoadSubcategoriesCompleted value)? completed,
    TResult Function(LoadSubcategoriesError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class LoadSubcategoriesInitial implements LoadSubcategoriesState {
  const factory LoadSubcategoriesInitial() = _$LoadSubcategoriesInitialImpl;
}

/// @nodoc
abstract class _$$LoadSubcategoriesLoadingImplCopyWith<$Res> {
  factory _$$LoadSubcategoriesLoadingImplCopyWith(
          _$LoadSubcategoriesLoadingImpl value,
          $Res Function(_$LoadSubcategoriesLoadingImpl) then) =
      __$$LoadSubcategoriesLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadSubcategoriesLoadingImplCopyWithImpl<$Res>
    extends _$LoadSubcategoriesStateCopyWithImpl<$Res,
        _$LoadSubcategoriesLoadingImpl>
    implements _$$LoadSubcategoriesLoadingImplCopyWith<$Res> {
  __$$LoadSubcategoriesLoadingImplCopyWithImpl(
      _$LoadSubcategoriesLoadingImpl _value,
      $Res Function(_$LoadSubcategoriesLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadSubcategoriesLoadingImpl implements LoadSubcategoriesLoading {
  const _$LoadSubcategoriesLoadingImpl();

  @override
  String toString() {
    return 'LoadSubcategoriesState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadSubcategoriesLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> subcategories) completed,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> subcategories)? completed,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> subcategories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadSubcategoriesInitial value) initial,
    required TResult Function(LoadSubcategoriesLoading value) loading,
    required TResult Function(LoadSubcategoriesCompleted value) completed,
    required TResult Function(LoadSubcategoriesError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadSubcategoriesInitial value)? initial,
    TResult? Function(LoadSubcategoriesLoading value)? loading,
    TResult? Function(LoadSubcategoriesCompleted value)? completed,
    TResult? Function(LoadSubcategoriesError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadSubcategoriesInitial value)? initial,
    TResult Function(LoadSubcategoriesLoading value)? loading,
    TResult Function(LoadSubcategoriesCompleted value)? completed,
    TResult Function(LoadSubcategoriesError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadSubcategoriesLoading implements LoadSubcategoriesState {
  const factory LoadSubcategoriesLoading() = _$LoadSubcategoriesLoadingImpl;
}

/// @nodoc
abstract class _$$LoadSubcategoriesCompletedImplCopyWith<$Res> {
  factory _$$LoadSubcategoriesCompletedImplCopyWith(
          _$LoadSubcategoriesCompletedImpl value,
          $Res Function(_$LoadSubcategoriesCompletedImpl) then) =
      __$$LoadSubcategoriesCompletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<String> subcategories});
}

/// @nodoc
class __$$LoadSubcategoriesCompletedImplCopyWithImpl<$Res>
    extends _$LoadSubcategoriesStateCopyWithImpl<$Res,
        _$LoadSubcategoriesCompletedImpl>
    implements _$$LoadSubcategoriesCompletedImplCopyWith<$Res> {
  __$$LoadSubcategoriesCompletedImplCopyWithImpl(
      _$LoadSubcategoriesCompletedImpl _value,
      $Res Function(_$LoadSubcategoriesCompletedImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subcategories = null,
  }) {
    return _then(_$LoadSubcategoriesCompletedImpl(
      null == subcategories
          ? _value._subcategories
          : subcategories // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

class _$LoadSubcategoriesCompletedImpl implements LoadSubcategoriesCompleted {
  const _$LoadSubcategoriesCompletedImpl(final List<String> subcategories)
      : _subcategories = subcategories;

  final List<String> _subcategories;
  @override
  List<String> get subcategories {
    if (_subcategories is EqualUnmodifiableListView) return _subcategories;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_subcategories);
  }

  @override
  String toString() {
    return 'LoadSubcategoriesState.completed(subcategories: $subcategories)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadSubcategoriesCompletedImpl &&
            const DeepCollectionEquality()
                .equals(other._subcategories, _subcategories));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_subcategories));

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadSubcategoriesCompletedImplCopyWith<_$LoadSubcategoriesCompletedImpl>
      get copyWith => __$$LoadSubcategoriesCompletedImplCopyWithImpl<
          _$LoadSubcategoriesCompletedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> subcategories) completed,
    required TResult Function(String message) error,
  }) {
    return completed(subcategories);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> subcategories)? completed,
    TResult? Function(String message)? error,
  }) {
    return completed?.call(subcategories);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> subcategories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(subcategories);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadSubcategoriesInitial value) initial,
    required TResult Function(LoadSubcategoriesLoading value) loading,
    required TResult Function(LoadSubcategoriesCompleted value) completed,
    required TResult Function(LoadSubcategoriesError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadSubcategoriesInitial value)? initial,
    TResult? Function(LoadSubcategoriesLoading value)? loading,
    TResult? Function(LoadSubcategoriesCompleted value)? completed,
    TResult? Function(LoadSubcategoriesError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadSubcategoriesInitial value)? initial,
    TResult Function(LoadSubcategoriesLoading value)? loading,
    TResult Function(LoadSubcategoriesCompleted value)? completed,
    TResult Function(LoadSubcategoriesError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class LoadSubcategoriesCompleted implements LoadSubcategoriesState {
  const factory LoadSubcategoriesCompleted(final List<String> subcategories) =
      _$LoadSubcategoriesCompletedImpl;

  List<String> get subcategories;

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadSubcategoriesCompletedImplCopyWith<_$LoadSubcategoriesCompletedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadSubcategoriesErrorImplCopyWith<$Res> {
  factory _$$LoadSubcategoriesErrorImplCopyWith(
          _$LoadSubcategoriesErrorImpl value,
          $Res Function(_$LoadSubcategoriesErrorImpl) then) =
      __$$LoadSubcategoriesErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$LoadSubcategoriesErrorImplCopyWithImpl<$Res>
    extends _$LoadSubcategoriesStateCopyWithImpl<$Res,
        _$LoadSubcategoriesErrorImpl>
    implements _$$LoadSubcategoriesErrorImplCopyWith<$Res> {
  __$$LoadSubcategoriesErrorImplCopyWithImpl(
      _$LoadSubcategoriesErrorImpl _value,
      $Res Function(_$LoadSubcategoriesErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$LoadSubcategoriesErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$LoadSubcategoriesErrorImpl implements LoadSubcategoriesError {
  const _$LoadSubcategoriesErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'LoadSubcategoriesState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadSubcategoriesErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadSubcategoriesErrorImplCopyWith<_$LoadSubcategoriesErrorImpl>
      get copyWith => __$$LoadSubcategoriesErrorImplCopyWithImpl<
          _$LoadSubcategoriesErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<String> subcategories) completed,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<String> subcategories)? completed,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<String> subcategories)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadSubcategoriesInitial value) initial,
    required TResult Function(LoadSubcategoriesLoading value) loading,
    required TResult Function(LoadSubcategoriesCompleted value) completed,
    required TResult Function(LoadSubcategoriesError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadSubcategoriesInitial value)? initial,
    TResult? Function(LoadSubcategoriesLoading value)? loading,
    TResult? Function(LoadSubcategoriesCompleted value)? completed,
    TResult? Function(LoadSubcategoriesError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadSubcategoriesInitial value)? initial,
    TResult Function(LoadSubcategoriesLoading value)? loading,
    TResult Function(LoadSubcategoriesCompleted value)? completed,
    TResult Function(LoadSubcategoriesError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class LoadSubcategoriesError implements LoadSubcategoriesState {
  const factory LoadSubcategoriesError(final String message) =
      _$LoadSubcategoriesErrorImpl;

  String get message;

  /// Create a copy of LoadSubcategoriesState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadSubcategoriesErrorImplCopyWith<_$LoadSubcategoriesErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SuggestCategoryState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(CategorySuggestion suggestion) completed,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(CategorySuggestion suggestion)? completed,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(CategorySuggestion suggestion)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SuggestCategoryInitial value) initial,
    required TResult Function(SuggestCategoryLoading value) loading,
    required TResult Function(SuggestCategoryCompleted value) completed,
    required TResult Function(SuggestCategoryError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SuggestCategoryInitial value)? initial,
    TResult? Function(SuggestCategoryLoading value)? loading,
    TResult? Function(SuggestCategoryCompleted value)? completed,
    TResult? Function(SuggestCategoryError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SuggestCategoryInitial value)? initial,
    TResult Function(SuggestCategoryLoading value)? loading,
    TResult Function(SuggestCategoryCompleted value)? completed,
    TResult Function(SuggestCategoryError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SuggestCategoryStateCopyWith<$Res> {
  factory $SuggestCategoryStateCopyWith(SuggestCategoryState value,
          $Res Function(SuggestCategoryState) then) =
      _$SuggestCategoryStateCopyWithImpl<$Res, SuggestCategoryState>;
}

/// @nodoc
class _$SuggestCategoryStateCopyWithImpl<$Res,
        $Val extends SuggestCategoryState>
    implements $SuggestCategoryStateCopyWith<$Res> {
  _$SuggestCategoryStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$SuggestCategoryInitialImplCopyWith<$Res> {
  factory _$$SuggestCategoryInitialImplCopyWith(
          _$SuggestCategoryInitialImpl value,
          $Res Function(_$SuggestCategoryInitialImpl) then) =
      __$$SuggestCategoryInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SuggestCategoryInitialImplCopyWithImpl<$Res>
    extends _$SuggestCategoryStateCopyWithImpl<$Res,
        _$SuggestCategoryInitialImpl>
    implements _$$SuggestCategoryInitialImplCopyWith<$Res> {
  __$$SuggestCategoryInitialImplCopyWithImpl(
      _$SuggestCategoryInitialImpl _value,
      $Res Function(_$SuggestCategoryInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SuggestCategoryInitialImpl implements SuggestCategoryInitial {
  const _$SuggestCategoryInitialImpl();

  @override
  String toString() {
    return 'SuggestCategoryState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuggestCategoryInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(CategorySuggestion suggestion) completed,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(CategorySuggestion suggestion)? completed,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(CategorySuggestion suggestion)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SuggestCategoryInitial value) initial,
    required TResult Function(SuggestCategoryLoading value) loading,
    required TResult Function(SuggestCategoryCompleted value) completed,
    required TResult Function(SuggestCategoryError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SuggestCategoryInitial value)? initial,
    TResult? Function(SuggestCategoryLoading value)? loading,
    TResult? Function(SuggestCategoryCompleted value)? completed,
    TResult? Function(SuggestCategoryError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SuggestCategoryInitial value)? initial,
    TResult Function(SuggestCategoryLoading value)? loading,
    TResult Function(SuggestCategoryCompleted value)? completed,
    TResult Function(SuggestCategoryError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class SuggestCategoryInitial implements SuggestCategoryState {
  const factory SuggestCategoryInitial() = _$SuggestCategoryInitialImpl;
}

/// @nodoc
abstract class _$$SuggestCategoryLoadingImplCopyWith<$Res> {
  factory _$$SuggestCategoryLoadingImplCopyWith(
          _$SuggestCategoryLoadingImpl value,
          $Res Function(_$SuggestCategoryLoadingImpl) then) =
      __$$SuggestCategoryLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SuggestCategoryLoadingImplCopyWithImpl<$Res>
    extends _$SuggestCategoryStateCopyWithImpl<$Res,
        _$SuggestCategoryLoadingImpl>
    implements _$$SuggestCategoryLoadingImplCopyWith<$Res> {
  __$$SuggestCategoryLoadingImplCopyWithImpl(
      _$SuggestCategoryLoadingImpl _value,
      $Res Function(_$SuggestCategoryLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$SuggestCategoryLoadingImpl implements SuggestCategoryLoading {
  const _$SuggestCategoryLoadingImpl();

  @override
  String toString() {
    return 'SuggestCategoryState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuggestCategoryLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(CategorySuggestion suggestion) completed,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(CategorySuggestion suggestion)? completed,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(CategorySuggestion suggestion)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SuggestCategoryInitial value) initial,
    required TResult Function(SuggestCategoryLoading value) loading,
    required TResult Function(SuggestCategoryCompleted value) completed,
    required TResult Function(SuggestCategoryError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SuggestCategoryInitial value)? initial,
    TResult? Function(SuggestCategoryLoading value)? loading,
    TResult? Function(SuggestCategoryCompleted value)? completed,
    TResult? Function(SuggestCategoryError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SuggestCategoryInitial value)? initial,
    TResult Function(SuggestCategoryLoading value)? loading,
    TResult Function(SuggestCategoryCompleted value)? completed,
    TResult Function(SuggestCategoryError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class SuggestCategoryLoading implements SuggestCategoryState {
  const factory SuggestCategoryLoading() = _$SuggestCategoryLoadingImpl;
}

/// @nodoc
abstract class _$$SuggestCategoryCompletedImplCopyWith<$Res> {
  factory _$$SuggestCategoryCompletedImplCopyWith(
          _$SuggestCategoryCompletedImpl value,
          $Res Function(_$SuggestCategoryCompletedImpl) then) =
      __$$SuggestCategoryCompletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({CategorySuggestion suggestion});
}

/// @nodoc
class __$$SuggestCategoryCompletedImplCopyWithImpl<$Res>
    extends _$SuggestCategoryStateCopyWithImpl<$Res,
        _$SuggestCategoryCompletedImpl>
    implements _$$SuggestCategoryCompletedImplCopyWith<$Res> {
  __$$SuggestCategoryCompletedImplCopyWithImpl(
      _$SuggestCategoryCompletedImpl _value,
      $Res Function(_$SuggestCategoryCompletedImpl) _then)
      : super(_value, _then);

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? suggestion = null,
  }) {
    return _then(_$SuggestCategoryCompletedImpl(
      null == suggestion
          ? _value.suggestion
          : suggestion // ignore: cast_nullable_to_non_nullable
              as CategorySuggestion,
    ));
  }
}

/// @nodoc

class _$SuggestCategoryCompletedImpl implements SuggestCategoryCompleted {
  const _$SuggestCategoryCompletedImpl(this.suggestion);

  @override
  final CategorySuggestion suggestion;

  @override
  String toString() {
    return 'SuggestCategoryState.completed(suggestion: $suggestion)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuggestCategoryCompletedImpl &&
            (identical(other.suggestion, suggestion) ||
                other.suggestion == suggestion));
  }

  @override
  int get hashCode => Object.hash(runtimeType, suggestion);

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SuggestCategoryCompletedImplCopyWith<_$SuggestCategoryCompletedImpl>
      get copyWith => __$$SuggestCategoryCompletedImplCopyWithImpl<
          _$SuggestCategoryCompletedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(CategorySuggestion suggestion) completed,
    required TResult Function(String message) error,
  }) {
    return completed(suggestion);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(CategorySuggestion suggestion)? completed,
    TResult? Function(String message)? error,
  }) {
    return completed?.call(suggestion);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(CategorySuggestion suggestion)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(suggestion);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SuggestCategoryInitial value) initial,
    required TResult Function(SuggestCategoryLoading value) loading,
    required TResult Function(SuggestCategoryCompleted value) completed,
    required TResult Function(SuggestCategoryError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SuggestCategoryInitial value)? initial,
    TResult? Function(SuggestCategoryLoading value)? loading,
    TResult? Function(SuggestCategoryCompleted value)? completed,
    TResult? Function(SuggestCategoryError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SuggestCategoryInitial value)? initial,
    TResult Function(SuggestCategoryLoading value)? loading,
    TResult Function(SuggestCategoryCompleted value)? completed,
    TResult Function(SuggestCategoryError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class SuggestCategoryCompleted implements SuggestCategoryState {
  const factory SuggestCategoryCompleted(final CategorySuggestion suggestion) =
      _$SuggestCategoryCompletedImpl;

  CategorySuggestion get suggestion;

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SuggestCategoryCompletedImplCopyWith<_$SuggestCategoryCompletedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SuggestCategoryErrorImplCopyWith<$Res> {
  factory _$$SuggestCategoryErrorImplCopyWith(_$SuggestCategoryErrorImpl value,
          $Res Function(_$SuggestCategoryErrorImpl) then) =
      __$$SuggestCategoryErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$SuggestCategoryErrorImplCopyWithImpl<$Res>
    extends _$SuggestCategoryStateCopyWithImpl<$Res, _$SuggestCategoryErrorImpl>
    implements _$$SuggestCategoryErrorImplCopyWith<$Res> {
  __$$SuggestCategoryErrorImplCopyWithImpl(_$SuggestCategoryErrorImpl _value,
      $Res Function(_$SuggestCategoryErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$SuggestCategoryErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SuggestCategoryErrorImpl implements SuggestCategoryError {
  const _$SuggestCategoryErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'SuggestCategoryState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SuggestCategoryErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SuggestCategoryErrorImplCopyWith<_$SuggestCategoryErrorImpl>
      get copyWith =>
          __$$SuggestCategoryErrorImplCopyWithImpl<_$SuggestCategoryErrorImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(CategorySuggestion suggestion) completed,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(CategorySuggestion suggestion)? completed,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(CategorySuggestion suggestion)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SuggestCategoryInitial value) initial,
    required TResult Function(SuggestCategoryLoading value) loading,
    required TResult Function(SuggestCategoryCompleted value) completed,
    required TResult Function(SuggestCategoryError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SuggestCategoryInitial value)? initial,
    TResult? Function(SuggestCategoryLoading value)? loading,
    TResult? Function(SuggestCategoryCompleted value)? completed,
    TResult? Function(SuggestCategoryError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SuggestCategoryInitial value)? initial,
    TResult Function(SuggestCategoryLoading value)? loading,
    TResult Function(SuggestCategoryCompleted value)? completed,
    TResult Function(SuggestCategoryError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class SuggestCategoryError implements SuggestCategoryState {
  const factory SuggestCategoryError(final String message) =
      _$SuggestCategoryErrorImpl;

  String get message;

  /// Create a copy of SuggestCategoryState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SuggestCategoryErrorImplCopyWith<_$SuggestCategoryErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ValidateTransactionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool isValid) completed,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool isValid)? completed,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool isValid)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ValidateTransactionInitial value) initial,
    required TResult Function(ValidateTransactionLoading value) loading,
    required TResult Function(ValidateTransactionCompleted value) completed,
    required TResult Function(ValidateTransactionError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ValidateTransactionInitial value)? initial,
    TResult? Function(ValidateTransactionLoading value)? loading,
    TResult? Function(ValidateTransactionCompleted value)? completed,
    TResult? Function(ValidateTransactionError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ValidateTransactionInitial value)? initial,
    TResult Function(ValidateTransactionLoading value)? loading,
    TResult Function(ValidateTransactionCompleted value)? completed,
    TResult Function(ValidateTransactionError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValidateTransactionStateCopyWith<$Res> {
  factory $ValidateTransactionStateCopyWith(ValidateTransactionState value,
          $Res Function(ValidateTransactionState) then) =
      _$ValidateTransactionStateCopyWithImpl<$Res, ValidateTransactionState>;
}

/// @nodoc
class _$ValidateTransactionStateCopyWithImpl<$Res,
        $Val extends ValidateTransactionState>
    implements $ValidateTransactionStateCopyWith<$Res> {
  _$ValidateTransactionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ValidateTransactionInitialImplCopyWith<$Res> {
  factory _$$ValidateTransactionInitialImplCopyWith(
          _$ValidateTransactionInitialImpl value,
          $Res Function(_$ValidateTransactionInitialImpl) then) =
      __$$ValidateTransactionInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ValidateTransactionInitialImplCopyWithImpl<$Res>
    extends _$ValidateTransactionStateCopyWithImpl<$Res,
        _$ValidateTransactionInitialImpl>
    implements _$$ValidateTransactionInitialImplCopyWith<$Res> {
  __$$ValidateTransactionInitialImplCopyWithImpl(
      _$ValidateTransactionInitialImpl _value,
      $Res Function(_$ValidateTransactionInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ValidateTransactionInitialImpl implements ValidateTransactionInitial {
  const _$ValidateTransactionInitialImpl();

  @override
  String toString() {
    return 'ValidateTransactionState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ValidateTransactionInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool isValid) completed,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool isValid)? completed,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool isValid)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ValidateTransactionInitial value) initial,
    required TResult Function(ValidateTransactionLoading value) loading,
    required TResult Function(ValidateTransactionCompleted value) completed,
    required TResult Function(ValidateTransactionError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ValidateTransactionInitial value)? initial,
    TResult? Function(ValidateTransactionLoading value)? loading,
    TResult? Function(ValidateTransactionCompleted value)? completed,
    TResult? Function(ValidateTransactionError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ValidateTransactionInitial value)? initial,
    TResult Function(ValidateTransactionLoading value)? loading,
    TResult Function(ValidateTransactionCompleted value)? completed,
    TResult Function(ValidateTransactionError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ValidateTransactionInitial implements ValidateTransactionState {
  const factory ValidateTransactionInitial() = _$ValidateTransactionInitialImpl;
}

/// @nodoc
abstract class _$$ValidateTransactionLoadingImplCopyWith<$Res> {
  factory _$$ValidateTransactionLoadingImplCopyWith(
          _$ValidateTransactionLoadingImpl value,
          $Res Function(_$ValidateTransactionLoadingImpl) then) =
      __$$ValidateTransactionLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ValidateTransactionLoadingImplCopyWithImpl<$Res>
    extends _$ValidateTransactionStateCopyWithImpl<$Res,
        _$ValidateTransactionLoadingImpl>
    implements _$$ValidateTransactionLoadingImplCopyWith<$Res> {
  __$$ValidateTransactionLoadingImplCopyWithImpl(
      _$ValidateTransactionLoadingImpl _value,
      $Res Function(_$ValidateTransactionLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ValidateTransactionLoadingImpl implements ValidateTransactionLoading {
  const _$ValidateTransactionLoadingImpl();

  @override
  String toString() {
    return 'ValidateTransactionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ValidateTransactionLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool isValid) completed,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool isValid)? completed,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool isValid)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ValidateTransactionInitial value) initial,
    required TResult Function(ValidateTransactionLoading value) loading,
    required TResult Function(ValidateTransactionCompleted value) completed,
    required TResult Function(ValidateTransactionError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ValidateTransactionInitial value)? initial,
    TResult? Function(ValidateTransactionLoading value)? loading,
    TResult? Function(ValidateTransactionCompleted value)? completed,
    TResult? Function(ValidateTransactionError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ValidateTransactionInitial value)? initial,
    TResult Function(ValidateTransactionLoading value)? loading,
    TResult Function(ValidateTransactionCompleted value)? completed,
    TResult Function(ValidateTransactionError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class ValidateTransactionLoading implements ValidateTransactionState {
  const factory ValidateTransactionLoading() = _$ValidateTransactionLoadingImpl;
}

/// @nodoc
abstract class _$$ValidateTransactionCompletedImplCopyWith<$Res> {
  factory _$$ValidateTransactionCompletedImplCopyWith(
          _$ValidateTransactionCompletedImpl value,
          $Res Function(_$ValidateTransactionCompletedImpl) then) =
      __$$ValidateTransactionCompletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isValid});
}

/// @nodoc
class __$$ValidateTransactionCompletedImplCopyWithImpl<$Res>
    extends _$ValidateTransactionStateCopyWithImpl<$Res,
        _$ValidateTransactionCompletedImpl>
    implements _$$ValidateTransactionCompletedImplCopyWith<$Res> {
  __$$ValidateTransactionCompletedImplCopyWithImpl(
      _$ValidateTransactionCompletedImpl _value,
      $Res Function(_$ValidateTransactionCompletedImpl) _then)
      : super(_value, _then);

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isValid = null,
  }) {
    return _then(_$ValidateTransactionCompletedImpl(
      null == isValid
          ? _value.isValid
          : isValid // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$ValidateTransactionCompletedImpl
    implements ValidateTransactionCompleted {
  const _$ValidateTransactionCompletedImpl(this.isValid);

  @override
  final bool isValid;

  @override
  String toString() {
    return 'ValidateTransactionState.completed(isValid: $isValid)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ValidateTransactionCompletedImpl &&
            (identical(other.isValid, isValid) || other.isValid == isValid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isValid);

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ValidateTransactionCompletedImplCopyWith<
          _$ValidateTransactionCompletedImpl>
      get copyWith => __$$ValidateTransactionCompletedImplCopyWithImpl<
          _$ValidateTransactionCompletedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool isValid) completed,
    required TResult Function(String message) error,
  }) {
    return completed(isValid);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool isValid)? completed,
    TResult? Function(String message)? error,
  }) {
    return completed?.call(isValid);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool isValid)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(isValid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ValidateTransactionInitial value) initial,
    required TResult Function(ValidateTransactionLoading value) loading,
    required TResult Function(ValidateTransactionCompleted value) completed,
    required TResult Function(ValidateTransactionError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ValidateTransactionInitial value)? initial,
    TResult? Function(ValidateTransactionLoading value)? loading,
    TResult? Function(ValidateTransactionCompleted value)? completed,
    TResult? Function(ValidateTransactionError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ValidateTransactionInitial value)? initial,
    TResult Function(ValidateTransactionLoading value)? loading,
    TResult Function(ValidateTransactionCompleted value)? completed,
    TResult Function(ValidateTransactionError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class ValidateTransactionCompleted
    implements ValidateTransactionState {
  const factory ValidateTransactionCompleted(final bool isValid) =
      _$ValidateTransactionCompletedImpl;

  bool get isValid;

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ValidateTransactionCompletedImplCopyWith<
          _$ValidateTransactionCompletedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ValidateTransactionErrorImplCopyWith<$Res> {
  factory _$$ValidateTransactionErrorImplCopyWith(
          _$ValidateTransactionErrorImpl value,
          $Res Function(_$ValidateTransactionErrorImpl) then) =
      __$$ValidateTransactionErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ValidateTransactionErrorImplCopyWithImpl<$Res>
    extends _$ValidateTransactionStateCopyWithImpl<$Res,
        _$ValidateTransactionErrorImpl>
    implements _$$ValidateTransactionErrorImplCopyWith<$Res> {
  __$$ValidateTransactionErrorImplCopyWithImpl(
      _$ValidateTransactionErrorImpl _value,
      $Res Function(_$ValidateTransactionErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ValidateTransactionErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ValidateTransactionErrorImpl implements ValidateTransactionError {
  const _$ValidateTransactionErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'ValidateTransactionState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ValidateTransactionErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ValidateTransactionErrorImplCopyWith<_$ValidateTransactionErrorImpl>
      get copyWith => __$$ValidateTransactionErrorImplCopyWithImpl<
          _$ValidateTransactionErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(bool isValid) completed,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(bool isValid)? completed,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(bool isValid)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ValidateTransactionInitial value) initial,
    required TResult Function(ValidateTransactionLoading value) loading,
    required TResult Function(ValidateTransactionCompleted value) completed,
    required TResult Function(ValidateTransactionError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ValidateTransactionInitial value)? initial,
    TResult? Function(ValidateTransactionLoading value)? loading,
    TResult? Function(ValidateTransactionCompleted value)? completed,
    TResult? Function(ValidateTransactionError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ValidateTransactionInitial value)? initial,
    TResult Function(ValidateTransactionLoading value)? loading,
    TResult Function(ValidateTransactionCompleted value)? completed,
    TResult Function(ValidateTransactionError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ValidateTransactionError implements ValidateTransactionState {
  const factory ValidateTransactionError(final String message) =
      _$ValidateTransactionErrorImpl;

  String get message;

  /// Create a copy of ValidateTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ValidateTransactionErrorImplCopyWith<_$ValidateTransactionErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddTransactionState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(TransactionEntity transaction) completed,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(TransactionEntity transaction)? completed,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(TransactionEntity transaction)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddTransactionInitial value) initial,
    required TResult Function(AddTransactionLoading value) loading,
    required TResult Function(AddTransactionCompleted value) completed,
    required TResult Function(AddTransactionError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddTransactionInitial value)? initial,
    TResult? Function(AddTransactionLoading value)? loading,
    TResult? Function(AddTransactionCompleted value)? completed,
    TResult? Function(AddTransactionError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddTransactionInitial value)? initial,
    TResult Function(AddTransactionLoading value)? loading,
    TResult Function(AddTransactionCompleted value)? completed,
    TResult Function(AddTransactionError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddTransactionStateCopyWith<$Res> {
  factory $AddTransactionStateCopyWith(
          AddTransactionState value, $Res Function(AddTransactionState) then) =
      _$AddTransactionStateCopyWithImpl<$Res, AddTransactionState>;
}

/// @nodoc
class _$AddTransactionStateCopyWithImpl<$Res, $Val extends AddTransactionState>
    implements $AddTransactionStateCopyWith<$Res> {
  _$AddTransactionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AddTransactionInitialImplCopyWith<$Res> {
  factory _$$AddTransactionInitialImplCopyWith(
          _$AddTransactionInitialImpl value,
          $Res Function(_$AddTransactionInitialImpl) then) =
      __$$AddTransactionInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddTransactionInitialImplCopyWithImpl<$Res>
    extends _$AddTransactionStateCopyWithImpl<$Res, _$AddTransactionInitialImpl>
    implements _$$AddTransactionInitialImplCopyWith<$Res> {
  __$$AddTransactionInitialImplCopyWithImpl(_$AddTransactionInitialImpl _value,
      $Res Function(_$AddTransactionInitialImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AddTransactionInitialImpl implements AddTransactionInitial {
  const _$AddTransactionInitialImpl();

  @override
  String toString() {
    return 'AddTransactionState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddTransactionInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(TransactionEntity transaction) completed,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(TransactionEntity transaction)? completed,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(TransactionEntity transaction)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddTransactionInitial value) initial,
    required TResult Function(AddTransactionLoading value) loading,
    required TResult Function(AddTransactionCompleted value) completed,
    required TResult Function(AddTransactionError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddTransactionInitial value)? initial,
    TResult? Function(AddTransactionLoading value)? loading,
    TResult? Function(AddTransactionCompleted value)? completed,
    TResult? Function(AddTransactionError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddTransactionInitial value)? initial,
    TResult Function(AddTransactionLoading value)? loading,
    TResult Function(AddTransactionCompleted value)? completed,
    TResult Function(AddTransactionError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class AddTransactionInitial implements AddTransactionState {
  const factory AddTransactionInitial() = _$AddTransactionInitialImpl;
}

/// @nodoc
abstract class _$$AddTransactionLoadingImplCopyWith<$Res> {
  factory _$$AddTransactionLoadingImplCopyWith(
          _$AddTransactionLoadingImpl value,
          $Res Function(_$AddTransactionLoadingImpl) then) =
      __$$AddTransactionLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddTransactionLoadingImplCopyWithImpl<$Res>
    extends _$AddTransactionStateCopyWithImpl<$Res, _$AddTransactionLoadingImpl>
    implements _$$AddTransactionLoadingImplCopyWith<$Res> {
  __$$AddTransactionLoadingImplCopyWithImpl(_$AddTransactionLoadingImpl _value,
      $Res Function(_$AddTransactionLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AddTransactionLoadingImpl implements AddTransactionLoading {
  const _$AddTransactionLoadingImpl();

  @override
  String toString() {
    return 'AddTransactionState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddTransactionLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(TransactionEntity transaction) completed,
    required TResult Function(String message) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(TransactionEntity transaction)? completed,
    TResult? Function(String message)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(TransactionEntity transaction)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddTransactionInitial value) initial,
    required TResult Function(AddTransactionLoading value) loading,
    required TResult Function(AddTransactionCompleted value) completed,
    required TResult Function(AddTransactionError value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddTransactionInitial value)? initial,
    TResult? Function(AddTransactionLoading value)? loading,
    TResult? Function(AddTransactionCompleted value)? completed,
    TResult? Function(AddTransactionError value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddTransactionInitial value)? initial,
    TResult Function(AddTransactionLoading value)? loading,
    TResult Function(AddTransactionCompleted value)? completed,
    TResult Function(AddTransactionError value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class AddTransactionLoading implements AddTransactionState {
  const factory AddTransactionLoading() = _$AddTransactionLoadingImpl;
}

/// @nodoc
abstract class _$$AddTransactionCompletedImplCopyWith<$Res> {
  factory _$$AddTransactionCompletedImplCopyWith(
          _$AddTransactionCompletedImpl value,
          $Res Function(_$AddTransactionCompletedImpl) then) =
      __$$AddTransactionCompletedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TransactionEntity transaction});
}

/// @nodoc
class __$$AddTransactionCompletedImplCopyWithImpl<$Res>
    extends _$AddTransactionStateCopyWithImpl<$Res,
        _$AddTransactionCompletedImpl>
    implements _$$AddTransactionCompletedImplCopyWith<$Res> {
  __$$AddTransactionCompletedImplCopyWithImpl(
      _$AddTransactionCompletedImpl _value,
      $Res Function(_$AddTransactionCompletedImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? transaction = null,
  }) {
    return _then(_$AddTransactionCompletedImpl(
      null == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as TransactionEntity,
    ));
  }
}

/// @nodoc

class _$AddTransactionCompletedImpl implements AddTransactionCompleted {
  const _$AddTransactionCompletedImpl(this.transaction);

  @override
  final TransactionEntity transaction;

  @override
  String toString() {
    return 'AddTransactionState.completed(transaction: $transaction)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddTransactionCompletedImpl &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(runtimeType, transaction);

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddTransactionCompletedImplCopyWith<_$AddTransactionCompletedImpl>
      get copyWith => __$$AddTransactionCompletedImplCopyWithImpl<
          _$AddTransactionCompletedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(TransactionEntity transaction) completed,
    required TResult Function(String message) error,
  }) {
    return completed(transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(TransactionEntity transaction)? completed,
    TResult? Function(String message)? error,
  }) {
    return completed?.call(transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(TransactionEntity transaction)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddTransactionInitial value) initial,
    required TResult Function(AddTransactionLoading value) loading,
    required TResult Function(AddTransactionCompleted value) completed,
    required TResult Function(AddTransactionError value) error,
  }) {
    return completed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddTransactionInitial value)? initial,
    TResult? Function(AddTransactionLoading value)? loading,
    TResult? Function(AddTransactionCompleted value)? completed,
    TResult? Function(AddTransactionError value)? error,
  }) {
    return completed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddTransactionInitial value)? initial,
    TResult Function(AddTransactionLoading value)? loading,
    TResult Function(AddTransactionCompleted value)? completed,
    TResult Function(AddTransactionError value)? error,
    required TResult orElse(),
  }) {
    if (completed != null) {
      return completed(this);
    }
    return orElse();
  }
}

abstract class AddTransactionCompleted implements AddTransactionState {
  const factory AddTransactionCompleted(final TransactionEntity transaction) =
      _$AddTransactionCompletedImpl;

  TransactionEntity get transaction;

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddTransactionCompletedImplCopyWith<_$AddTransactionCompletedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddTransactionErrorImplCopyWith<$Res> {
  factory _$$AddTransactionErrorImplCopyWith(_$AddTransactionErrorImpl value,
          $Res Function(_$AddTransactionErrorImpl) then) =
      __$$AddTransactionErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$AddTransactionErrorImplCopyWithImpl<$Res>
    extends _$AddTransactionStateCopyWithImpl<$Res, _$AddTransactionErrorImpl>
    implements _$$AddTransactionErrorImplCopyWith<$Res> {
  __$$AddTransactionErrorImplCopyWithImpl(_$AddTransactionErrorImpl _value,
      $Res Function(_$AddTransactionErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$AddTransactionErrorImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AddTransactionErrorImpl implements AddTransactionError {
  const _$AddTransactionErrorImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'AddTransactionState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddTransactionErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddTransactionErrorImplCopyWith<_$AddTransactionErrorImpl> get copyWith =>
      __$$AddTransactionErrorImplCopyWithImpl<_$AddTransactionErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(TransactionEntity transaction) completed,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(TransactionEntity transaction)? completed,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(TransactionEntity transaction)? completed,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddTransactionInitial value) initial,
    required TResult Function(AddTransactionLoading value) loading,
    required TResult Function(AddTransactionCompleted value) completed,
    required TResult Function(AddTransactionError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddTransactionInitial value)? initial,
    TResult? Function(AddTransactionLoading value)? loading,
    TResult? Function(AddTransactionCompleted value)? completed,
    TResult? Function(AddTransactionError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddTransactionInitial value)? initial,
    TResult Function(AddTransactionLoading value)? loading,
    TResult Function(AddTransactionCompleted value)? completed,
    TResult Function(AddTransactionError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class AddTransactionError implements AddTransactionState {
  const factory AddTransactionError(final String message) =
      _$AddTransactionErrorImpl;

  String get message;

  /// Create a copy of AddTransactionState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddTransactionErrorImplCopyWith<_$AddTransactionErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddTransactionMainState {
  /// State for loading categories operation
  LoadCategoriesState get loadCategories => throw _privateConstructorUsedError;

  /// State for loading subcategories operation
  LoadSubcategoriesState get loadSubcategories =>
      throw _privateConstructorUsedError;

  /// State for category suggestion operation
  SuggestCategoryState get suggestCategory =>
      throw _privateConstructorUsedError;

  /// State for transaction validation operation
  ValidateTransactionState get validateTransaction =>
      throw _privateConstructorUsedError;

  /// State for adding transaction operation
  AddTransactionState get addTransaction => throw _privateConstructorUsedError;

  /// Currently selected category
  String get selectedCategory => throw _privateConstructorUsedError;

  /// Currently selected subcategory
  String get selectedSubcategory => throw _privateConstructorUsedError;

  /// Current transaction amount
  double get amount => throw _privateConstructorUsedError;

  /// Current transaction description
  String? get description => throw _privateConstructorUsedError;

  /// Current transaction date and time
  DateTime? get dateTime => throw _privateConstructorUsedError;

  /// Current transaction type
  TransactionType get type => throw _privateConstructorUsedError;

  /// Current merchant name
  String? get merchant => throw _privateConstructorUsedError;

  /// Whether the form has been initialized
  bool get isInitialized => throw _privateConstructorUsedError;

  /// Whether the form has unsaved changes
  bool get hasUnsavedChanges => throw _privateConstructorUsedError;

  /// Whether the form is in edit mode
  bool get isEditMode => throw _privateConstructorUsedError;

  /// ID of the transaction being edited (if in edit mode)
  String? get editingTransactionId => throw _privateConstructorUsedError;

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AddTransactionMainStateCopyWith<AddTransactionMainState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddTransactionMainStateCopyWith<$Res> {
  factory $AddTransactionMainStateCopyWith(AddTransactionMainState value,
          $Res Function(AddTransactionMainState) then) =
      _$AddTransactionMainStateCopyWithImpl<$Res, AddTransactionMainState>;
  @useResult
  $Res call(
      {LoadCategoriesState loadCategories,
      LoadSubcategoriesState loadSubcategories,
      SuggestCategoryState suggestCategory,
      ValidateTransactionState validateTransaction,
      AddTransactionState addTransaction,
      String selectedCategory,
      String selectedSubcategory,
      double amount,
      String? description,
      DateTime? dateTime,
      TransactionType type,
      String? merchant,
      bool isInitialized,
      bool hasUnsavedChanges,
      bool isEditMode,
      String? editingTransactionId});

  $LoadCategoriesStateCopyWith<$Res> get loadCategories;
  $LoadSubcategoriesStateCopyWith<$Res> get loadSubcategories;
  $SuggestCategoryStateCopyWith<$Res> get suggestCategory;
  $ValidateTransactionStateCopyWith<$Res> get validateTransaction;
  $AddTransactionStateCopyWith<$Res> get addTransaction;
}

/// @nodoc
class _$AddTransactionMainStateCopyWithImpl<$Res,
        $Val extends AddTransactionMainState>
    implements $AddTransactionMainStateCopyWith<$Res> {
  _$AddTransactionMainStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loadCategories = null,
    Object? loadSubcategories = null,
    Object? suggestCategory = null,
    Object? validateTransaction = null,
    Object? addTransaction = null,
    Object? selectedCategory = null,
    Object? selectedSubcategory = null,
    Object? amount = null,
    Object? description = freezed,
    Object? dateTime = freezed,
    Object? type = null,
    Object? merchant = freezed,
    Object? isInitialized = null,
    Object? hasUnsavedChanges = null,
    Object? isEditMode = null,
    Object? editingTransactionId = freezed,
  }) {
    return _then(_value.copyWith(
      loadCategories: null == loadCategories
          ? _value.loadCategories
          : loadCategories // ignore: cast_nullable_to_non_nullable
              as LoadCategoriesState,
      loadSubcategories: null == loadSubcategories
          ? _value.loadSubcategories
          : loadSubcategories // ignore: cast_nullable_to_non_nullable
              as LoadSubcategoriesState,
      suggestCategory: null == suggestCategory
          ? _value.suggestCategory
          : suggestCategory // ignore: cast_nullable_to_non_nullable
              as SuggestCategoryState,
      validateTransaction: null == validateTransaction
          ? _value.validateTransaction
          : validateTransaction // ignore: cast_nullable_to_non_nullable
              as ValidateTransactionState,
      addTransaction: null == addTransaction
          ? _value.addTransaction
          : addTransaction // ignore: cast_nullable_to_non_nullable
              as AddTransactionState,
      selectedCategory: null == selectedCategory
          ? _value.selectedCategory
          : selectedCategory // ignore: cast_nullable_to_non_nullable
              as String,
      selectedSubcategory: null == selectedSubcategory
          ? _value.selectedSubcategory
          : selectedSubcategory // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      dateTime: freezed == dateTime
          ? _value.dateTime
          : dateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as TransactionType,
      merchant: freezed == merchant
          ? _value.merchant
          : merchant // ignore: cast_nullable_to_non_nullable
              as String?,
      isInitialized: null == isInitialized
          ? _value.isInitialized
          : isInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      hasUnsavedChanges: null == hasUnsavedChanges
          ? _value.hasUnsavedChanges
          : hasUnsavedChanges // ignore: cast_nullable_to_non_nullable
              as bool,
      isEditMode: null == isEditMode
          ? _value.isEditMode
          : isEditMode // ignore: cast_nullable_to_non_nullable
              as bool,
      editingTransactionId: freezed == editingTransactionId
          ? _value.editingTransactionId
          : editingTransactionId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LoadCategoriesStateCopyWith<$Res> get loadCategories {
    return $LoadCategoriesStateCopyWith<$Res>(_value.loadCategories, (value) {
      return _then(_value.copyWith(loadCategories: value) as $Val);
    });
  }

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LoadSubcategoriesStateCopyWith<$Res> get loadSubcategories {
    return $LoadSubcategoriesStateCopyWith<$Res>(_value.loadSubcategories,
        (value) {
      return _then(_value.copyWith(loadSubcategories: value) as $Val);
    });
  }

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SuggestCategoryStateCopyWith<$Res> get suggestCategory {
    return $SuggestCategoryStateCopyWith<$Res>(_value.suggestCategory, (value) {
      return _then(_value.copyWith(suggestCategory: value) as $Val);
    });
  }

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ValidateTransactionStateCopyWith<$Res> get validateTransaction {
    return $ValidateTransactionStateCopyWith<$Res>(_value.validateTransaction,
        (value) {
      return _then(_value.copyWith(validateTransaction: value) as $Val);
    });
  }

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AddTransactionStateCopyWith<$Res> get addTransaction {
    return $AddTransactionStateCopyWith<$Res>(_value.addTransaction, (value) {
      return _then(_value.copyWith(addTransaction: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AddTransactionMainStateImplCopyWith<$Res>
    implements $AddTransactionMainStateCopyWith<$Res> {
  factory _$$AddTransactionMainStateImplCopyWith(
          _$AddTransactionMainStateImpl value,
          $Res Function(_$AddTransactionMainStateImpl) then) =
      __$$AddTransactionMainStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {LoadCategoriesState loadCategories,
      LoadSubcategoriesState loadSubcategories,
      SuggestCategoryState suggestCategory,
      ValidateTransactionState validateTransaction,
      AddTransactionState addTransaction,
      String selectedCategory,
      String selectedSubcategory,
      double amount,
      String? description,
      DateTime? dateTime,
      TransactionType type,
      String? merchant,
      bool isInitialized,
      bool hasUnsavedChanges,
      bool isEditMode,
      String? editingTransactionId});

  @override
  $LoadCategoriesStateCopyWith<$Res> get loadCategories;
  @override
  $LoadSubcategoriesStateCopyWith<$Res> get loadSubcategories;
  @override
  $SuggestCategoryStateCopyWith<$Res> get suggestCategory;
  @override
  $ValidateTransactionStateCopyWith<$Res> get validateTransaction;
  @override
  $AddTransactionStateCopyWith<$Res> get addTransaction;
}

/// @nodoc
class __$$AddTransactionMainStateImplCopyWithImpl<$Res>
    extends _$AddTransactionMainStateCopyWithImpl<$Res,
        _$AddTransactionMainStateImpl>
    implements _$$AddTransactionMainStateImplCopyWith<$Res> {
  __$$AddTransactionMainStateImplCopyWithImpl(
      _$AddTransactionMainStateImpl _value,
      $Res Function(_$AddTransactionMainStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loadCategories = null,
    Object? loadSubcategories = null,
    Object? suggestCategory = null,
    Object? validateTransaction = null,
    Object? addTransaction = null,
    Object? selectedCategory = null,
    Object? selectedSubcategory = null,
    Object? amount = null,
    Object? description = freezed,
    Object? dateTime = freezed,
    Object? type = null,
    Object? merchant = freezed,
    Object? isInitialized = null,
    Object? hasUnsavedChanges = null,
    Object? isEditMode = null,
    Object? editingTransactionId = freezed,
  }) {
    return _then(_$AddTransactionMainStateImpl(
      loadCategories: null == loadCategories
          ? _value.loadCategories
          : loadCategories // ignore: cast_nullable_to_non_nullable
              as LoadCategoriesState,
      loadSubcategories: null == loadSubcategories
          ? _value.loadSubcategories
          : loadSubcategories // ignore: cast_nullable_to_non_nullable
              as LoadSubcategoriesState,
      suggestCategory: null == suggestCategory
          ? _value.suggestCategory
          : suggestCategory // ignore: cast_nullable_to_non_nullable
              as SuggestCategoryState,
      validateTransaction: null == validateTransaction
          ? _value.validateTransaction
          : validateTransaction // ignore: cast_nullable_to_non_nullable
              as ValidateTransactionState,
      addTransaction: null == addTransaction
          ? _value.addTransaction
          : addTransaction // ignore: cast_nullable_to_non_nullable
              as AddTransactionState,
      selectedCategory: null == selectedCategory
          ? _value.selectedCategory
          : selectedCategory // ignore: cast_nullable_to_non_nullable
              as String,
      selectedSubcategory: null == selectedSubcategory
          ? _value.selectedSubcategory
          : selectedSubcategory // ignore: cast_nullable_to_non_nullable
              as String,
      amount: null == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      dateTime: freezed == dateTime
          ? _value.dateTime
          : dateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as TransactionType,
      merchant: freezed == merchant
          ? _value.merchant
          : merchant // ignore: cast_nullable_to_non_nullable
              as String?,
      isInitialized: null == isInitialized
          ? _value.isInitialized
          : isInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      hasUnsavedChanges: null == hasUnsavedChanges
          ? _value.hasUnsavedChanges
          : hasUnsavedChanges // ignore: cast_nullable_to_non_nullable
              as bool,
      isEditMode: null == isEditMode
          ? _value.isEditMode
          : isEditMode // ignore: cast_nullable_to_non_nullable
              as bool,
      editingTransactionId: freezed == editingTransactionId
          ? _value.editingTransactionId
          : editingTransactionId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$AddTransactionMainStateImpl implements _AddTransactionMainState {
  const _$AddTransactionMainStateImpl(
      {this.loadCategories = const LoadCategoriesState.initial(),
      this.loadSubcategories = const LoadSubcategoriesState.initial(),
      this.suggestCategory = const SuggestCategoryState.initial(),
      this.validateTransaction = const ValidateTransactionState.initial(),
      this.addTransaction = const AddTransactionState.initial(),
      this.selectedCategory = '',
      this.selectedSubcategory = '',
      this.amount = 0.0,
      this.description,
      this.dateTime,
      this.type = TransactionType.expense,
      this.merchant,
      this.isInitialized = false,
      this.hasUnsavedChanges = false,
      this.isEditMode = false,
      this.editingTransactionId});

  /// State for loading categories operation
  @override
  @JsonKey()
  final LoadCategoriesState loadCategories;

  /// State for loading subcategories operation
  @override
  @JsonKey()
  final LoadSubcategoriesState loadSubcategories;

  /// State for category suggestion operation
  @override
  @JsonKey()
  final SuggestCategoryState suggestCategory;

  /// State for transaction validation operation
  @override
  @JsonKey()
  final ValidateTransactionState validateTransaction;

  /// State for adding transaction operation
  @override
  @JsonKey()
  final AddTransactionState addTransaction;

  /// Currently selected category
  @override
  @JsonKey()
  final String selectedCategory;

  /// Currently selected subcategory
  @override
  @JsonKey()
  final String selectedSubcategory;

  /// Current transaction amount
  @override
  @JsonKey()
  final double amount;

  /// Current transaction description
  @override
  final String? description;

  /// Current transaction date and time
  @override
  final DateTime? dateTime;

  /// Current transaction type
  @override
  @JsonKey()
  final TransactionType type;

  /// Current merchant name
  @override
  final String? merchant;

  /// Whether the form has been initialized
  @override
  @JsonKey()
  final bool isInitialized;

  /// Whether the form has unsaved changes
  @override
  @JsonKey()
  final bool hasUnsavedChanges;

  /// Whether the form is in edit mode
  @override
  @JsonKey()
  final bool isEditMode;

  /// ID of the transaction being edited (if in edit mode)
  @override
  final String? editingTransactionId;

  @override
  String toString() {
    return 'AddTransactionMainState(loadCategories: $loadCategories, loadSubcategories: $loadSubcategories, suggestCategory: $suggestCategory, validateTransaction: $validateTransaction, addTransaction: $addTransaction, selectedCategory: $selectedCategory, selectedSubcategory: $selectedSubcategory, amount: $amount, description: $description, dateTime: $dateTime, type: $type, merchant: $merchant, isInitialized: $isInitialized, hasUnsavedChanges: $hasUnsavedChanges, isEditMode: $isEditMode, editingTransactionId: $editingTransactionId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddTransactionMainStateImpl &&
            (identical(other.loadCategories, loadCategories) ||
                other.loadCategories == loadCategories) &&
            (identical(other.loadSubcategories, loadSubcategories) ||
                other.loadSubcategories == loadSubcategories) &&
            (identical(other.suggestCategory, suggestCategory) ||
                other.suggestCategory == suggestCategory) &&
            (identical(other.validateTransaction, validateTransaction) ||
                other.validateTransaction == validateTransaction) &&
            (identical(other.addTransaction, addTransaction) ||
                other.addTransaction == addTransaction) &&
            (identical(other.selectedCategory, selectedCategory) ||
                other.selectedCategory == selectedCategory) &&
            (identical(other.selectedSubcategory, selectedSubcategory) ||
                other.selectedSubcategory == selectedSubcategory) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.dateTime, dateTime) ||
                other.dateTime == dateTime) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.merchant, merchant) ||
                other.merchant == merchant) &&
            (identical(other.isInitialized, isInitialized) ||
                other.isInitialized == isInitialized) &&
            (identical(other.hasUnsavedChanges, hasUnsavedChanges) ||
                other.hasUnsavedChanges == hasUnsavedChanges) &&
            (identical(other.isEditMode, isEditMode) ||
                other.isEditMode == isEditMode) &&
            (identical(other.editingTransactionId, editingTransactionId) ||
                other.editingTransactionId == editingTransactionId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      loadCategories,
      loadSubcategories,
      suggestCategory,
      validateTransaction,
      addTransaction,
      selectedCategory,
      selectedSubcategory,
      amount,
      description,
      dateTime,
      type,
      merchant,
      isInitialized,
      hasUnsavedChanges,
      isEditMode,
      editingTransactionId);

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddTransactionMainStateImplCopyWith<_$AddTransactionMainStateImpl>
      get copyWith => __$$AddTransactionMainStateImplCopyWithImpl<
          _$AddTransactionMainStateImpl>(this, _$identity);
}

abstract class _AddTransactionMainState implements AddTransactionMainState {
  const factory _AddTransactionMainState(
      {final LoadCategoriesState loadCategories,
      final LoadSubcategoriesState loadSubcategories,
      final SuggestCategoryState suggestCategory,
      final ValidateTransactionState validateTransaction,
      final AddTransactionState addTransaction,
      final String selectedCategory,
      final String selectedSubcategory,
      final double amount,
      final String? description,
      final DateTime? dateTime,
      final TransactionType type,
      final String? merchant,
      final bool isInitialized,
      final bool hasUnsavedChanges,
      final bool isEditMode,
      final String? editingTransactionId}) = _$AddTransactionMainStateImpl;

  /// State for loading categories operation
  @override
  LoadCategoriesState get loadCategories;

  /// State for loading subcategories operation
  @override
  LoadSubcategoriesState get loadSubcategories;

  /// State for category suggestion operation
  @override
  SuggestCategoryState get suggestCategory;

  /// State for transaction validation operation
  @override
  ValidateTransactionState get validateTransaction;

  /// State for adding transaction operation
  @override
  AddTransactionState get addTransaction;

  /// Currently selected category
  @override
  String get selectedCategory;

  /// Currently selected subcategory
  @override
  String get selectedSubcategory;

  /// Current transaction amount
  @override
  double get amount;

  /// Current transaction description
  @override
  String? get description;

  /// Current transaction date and time
  @override
  DateTime? get dateTime;

  /// Current transaction type
  @override
  TransactionType get type;

  /// Current merchant name
  @override
  String? get merchant;

  /// Whether the form has been initialized
  @override
  bool get isInitialized;

  /// Whether the form has unsaved changes
  @override
  bool get hasUnsavedChanges;

  /// Whether the form is in edit mode
  @override
  bool get isEditMode;

  /// ID of the transaction being edited (if in edit mode)
  @override
  String? get editingTransactionId;

  /// Create a copy of AddTransactionMainState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddTransactionMainStateImplCopyWith<_$AddTransactionMainStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}
